<html>
<head>
    <script type="text/javascript"
            src="dygraph.min.js"></script>
    <script type="text/javascript"
            src="moment.min.js"></script>
    <link rel="stylesheet" href="dygraph.min.css" />
    <style>
        .annotation_sell_profit {
            background-color: lightgreen;
        }

        .annotation_sell_loss {
            background-color: lightpink;
        }

        .annotation_buy_profit {
            background-color: lightblue;
        }

        .annotation_buy_loss {
            background-color: yellow;
        }
    </style>
</head>
<body>
<div id="list"></div>
<div id="graphdiv2"
     style="width:1800px; height:1000px;"></div>
<script type="text/javascript">
    function nameAnnotation(ann) {
        return "(" + ann.series + ", " + ann.x + ")";
    }
    var dateIndex   = [];
    var annotationIndex = [];
    g = new Dygraph(
        document.getElementById("graphdiv2"),
        "/s.csv", // path to CSV file
        {
            delimiter: '|',
            //visibility: [true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true],
            visibility: ['%visibility%'],
            xValueParser: function(x) {
                dateIndex.push(new Date(x.trim()));
                return dateIndex.length - 1;
            },
            ticker: Dygraph.numericTicks,
            axes: {
                x: {
                    valueFormatter: function (val, opts, series_name, dygraph) {
                        // val is the date, which we have rewritten to the array's index.
                        // So here we can exchange it back for the actual date, and format it
                        if (!dateIndex[val]) {
                            return '';
                        }
                        var ret = moment(dateIndex[val]).format("YYYY-MM-DD HH:mm");
                        if (annotationIndex[val]) {
                            ret += ' ' + annotationIndex[val];
                        }
                        return ret;
                    },
                    axisLabelFormatter: function (val, granularity, opts, dygraph) {
                        if (!dateIndex[val]) {
                            return '';
                        }
                        return moment(dateIndex[val]).format("MMM DD HH:mm");
                    }
                }
            },
            series: {
                strokeWidth: 2,
                drawPoints: true,
                pointSize: 1.5,
                'tubeSizePrice': {
                    strokeWidth: 3.0,
                    color: 'pink',
                },
                'tubeSizePriceP': {
                    strokeWidth: 1.0,
                    color: 'pink',
                },
                'expectTubeSize': {
                    strokeWidth: 3.0,
                    color: 'lightgreen',
                },
                'expectTubeSizeP': {
                    strokeWidth: 1.0,
                    color: 'lightgreen',
                },
                'expectProfit': {
                    strokeWidth: 3.0,
                    color: 'lightblue',
                },
                'expectProfitP': {
                    strokeWidth: 1.0,
                    color: 'lightblue',
                },
                'true': {
                    strokeWidth: 3.0,
                    color: 'blue',
                },
                'smaTube': {
                    strokeWidth: 5.0,
                    color: 'blue',
                },
                'average' : {
                    strokeWidth: 4.0,
                    color: 'turquoise',
                },
                'averageTop' : {
                    strokeWidth: 2.0,
                    color: 'turquoise',
                },
                'averageBottom' : {
                    strokeWidth: 2.0,
                    color: 'turquoise',
                },
                'investBottom' : {
                    strokeWidth: 2.0,
                    color: 'red',
                },
                'investTop' : {
                    strokeWidth: 2.0,
                    color: 'red',
                },
                'deadLineTop' : {
                    strokeWidth: 5.0,
                    color: 'green',
                },
                'smaSlowest': {
                    strokeWidth: 5.0,
                    pointSize: 2,
                    highlightCircleSize: 16,
                    color: 'orange',
                },
                'smaSlow': {
                    strokeWidth: 5.0,
                    color: 'purple',
                },
                'smaFast': {
                    strokeWidth: 5.0,
                    color: 'red',
                },
                'emaFast': {
                    strokeWidth: 3.0,
                    color: 'olive',
                },
                'ema2': {
                    strokeWidth: 3.0,
                    color: 'black',
                },
                'bye': {
                    connectSeparatedPoints: true,
                    drawPoints: true,
                    strokeWidth: 1,
                    pointSize: 3,
                    highlightCircleSize: 5
                },
                'sell': {
                    connectSeparatedPoints: true,
                    drawPoints: true,
                    strokeWidth: 1,
                    pointSize: 3,
                    highlightCircleSize: 5
                },
                'position': {
                    connectSeparatedPoints: true,
                    showRoller: true
                },
                'candleBuySell': {
                    connectSeparatedPoints: true,
                    showRoller: true,
                    drawPoints: true,
                    pointSize: 2,
                },
                'maxClose': {
                    strokeWidth: 3.0,
                    color: 'green',
                },
                'minClose': {
                    strokeWidth: 3.0,
                    color: 'red',
                },
            },
            drawCallback: function(g) {
                var ann = g.annotations();
                var html = "";
                for (var i = 0; i < ann.length; i++) {
                    var name = nameAnnotation(ann[i]);
                    html += "<span id='" + name + "'>";
                    html += name + ": " + (ann[i].shortText || '(icon)');
                    html += " -> " + ann[i].text + "</span><br/>";
                }
                document.getElementById("list").innerHTML = html;
            },
            plotter: function candlestickPlotter(e) {
                if (e.seriesIndex > 3 || ['open', 'close', 'high', 'low'].indexOf(e.setName) === false) {
                    Dygraph.Plotters.linePlotter(e);
                    return;
                }
                // This is the officially endorsed way to plot all the series at once.
                if (e.seriesIndex !== 0) return;

                var getPrices = function(sets) {
                    var prices = [];
                    var price;
                    for (var p = 0 ; p < sets[0].length; p++) {
                        price = {
                            open : sets[0][p].yval,
                            high : sets[1][p].yval,
                            low : sets[2][p].yval,
                            close : sets[3][p].yval,
                            openY : sets[0][p].y,
                            highY : sets[1][p].y,
                            lowY : sets[2][p].y,
                            closeY : sets[3][p].y
                        };
                        prices.push(price);
                    }
                    return prices;
                };

                var sets = e.allSeriesPoints.slice(0, 4); // Slice first four sets for candlestick chart
                var prices = getPrices(sets);
                var area = e.plotArea;
                var ctx = e.drawingContext;
                ctx.strokeStyle = '#202020';
                ctx.lineWidth = 0.6;

                var minBarWidth = 2;
                var numBars = prices.length + 1; // To compensate the probably removed first "incomplete" bar
                var barWidth = Math.round(area.w / numBars);
                if (barWidth % 2 !== 0) {
                    barWidth--;
                }
                barWidth = Math.max(barWidth, minBarWidth);

                var price;
                for (var p = 0 ; p < prices.length; p++) {
                    ctx.beginPath();

                    price = prices[p];
                    var topY = area.h * price.highY + area.y;
                    var bottomY = area.h * price.lowY + area.y;
                    var centerX = Math.floor(area.x + sets[0][p].x * area.w) + 0.5; // crisper rendering
                    ctx.moveTo(centerX, topY);
                    ctx.lineTo(centerX, bottomY);
                    ctx.closePath();
                    ctx.stroke();
                    var bodyY;
                    if (price.open > price.close) {
                        ctx.fillStyle = 'rgba(244, 44, 44, 1.0)';//'#d9534f';
                        bodyY = area.h * price.openY + area.y;
                    }
                    else {
                        ctx.fillStyle ='#5cb85c';//'rgba(44, 244, 44, 1.0)';
                        bodyY = area.h * price.closeY  + area.y;
                    }
                    var bodyHeight = area.h * Math.max(0.001, Math.abs(price.openY - price.closeY));
                    ctx.fillRect(centerX - barWidth / 2, bodyY, barWidth,  bodyHeight);
                }
            },
        }
    );
    g.ready(function() {
        req = new XMLHttpRequest();
        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if (req.status === 200 ||  // Normal http
                    req.status === 0) {    // Chrome w/ --allow-file-access-from-files
                    var lines = req.responseText.split("\n");
                    var annotations = [];
                    var buyPrice;
                    var profit = 0.0;
                    for (var i = 1; i < lines.length; i++) {
                        var line = lines[i];
                        if (line.length === 0) continue;
                        if (line[0] == '#') continue;
                        var inFields = line.split("|");
                        if (inFields.length < 3) continue;
                        var date = new Date(inFields[0].trim()).getTime();
                        var index;
                        for (var j = 0; j < dateIndex.length; j++) {
                            if (dateIndex[j].getTime() >= date) {
                                index = j;
                                break;
                            }
                        }
                        var text;
                        var cssClass = 'annotation';
                        if (inFields[1].trim() === 'B') {
                            buyPrice = parseFloat(inFields[2]);
                            text = 'Buy by ' + inFields[2];
                        } else {
                            text = 'Sell by ' + inFields[2];
                            if (buyPrice) {
                                var buyCssClass;
                                var sellPrice = parseFloat(inFields[2]);
                                if (buyPrice < sellPrice) {
                                    cssClass = 'annotation_sell_profit';
                                    buyCssClass = 'annotation_buy_profit';
                                    var curProfit = ((sellPrice * 100 / buyPrice) - 100);
                                    profit += curProfit;
                                    text += ' with profit ' + curProfit.toFixed(2) + '%';
                                } else {
                                    cssClass = 'annotation_sell_loss';
                                    buyCssClass = 'annotation_buy_loss';
                                    var curLoss = ((buyPrice * 100 / sellPrice) - 100);
                                    profit -= curLoss;
                                    text += ' with loss -' + curLoss.toFixed(2) + '%';
                                }
                                annotations[annotations.length - 1].cssClass = buyCssClass;
                            }
                        }
                        if (index !== undefined) {
                            annotations.push({
                                series: 'close',
                                xval: index,
                                x: inFields[0] + ' profit ' + profit.toFixed(2) + '%' + (annotationIndex[index] ? ' ' + annotationIndex[index] : ''),
                                shortText: inFields[1],
                                cssClass: cssClass,
                                text: text
                            });
                        }
                    }
                    if (profit) {
                        annotations.push({
                            series: 'ema2',
                            xval: dateIndex.length - 1,
                            x: 'Total',
                            shortText: 'T',
                            text: 'Total profit ' + profit.toFixed(2) + '%'
                        });
                    }
                    g.setAnnotations(annotations);
                }
            }
        };

        req2 = new XMLHttpRequest();
        req2.onreadystatechange = function () {
            if (req2.readyState == 4) {
                if (req2.status === 200 ||  // Normal http
                    req2.status === 0) {    // Chrome w/ --allow-file-access-from-files
                    var lines = req2.responseText.split("\n");
                    for (var i = 1; i < lines.length; i++) {
                        var line = lines[i];
                        if (line.length === 0) continue;
                        if (line[0] == '#') continue;
                        var inFields = line.split("|");
                        annotationIndex[i - 1] = inFields.length > 14 ? inFields[14] : inFields[inFields.length - 1];
                    }
                }
            }
            req.open("GET", '/a.csv', true);
            req.send(null);
        }

        req2.open("GET", '/s.csv', true);
        req2.send(null);
    });
</script>
</body>
</html>